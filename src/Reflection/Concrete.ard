\import Control.Applicative
\import Control.Monad
\import Data.Foldable
\import Data.Functor
\import Data.List (List, map \as listMap)
\import Data.Maybe
\import Data.Traversable
\import Debug.Meta
\import Function
\import Function.Meta
\import Meta
\import Paths.Meta

\data Var (B A : \Set)
  | Bound B
  | Free A

\data ExprF (ctx : \Set) : \Set
  | varF ctx
  | numF (n : Int)
  | appF (e : ExprF ctx) (args : List (ExprF ctx))
  | lamF (e : ExprF (Maybe ctx))

-- \func abstract {A B : \Set} {F : \Set -> \Set} {M : Monad F} (f : A -> Maybe B) (e : F A) : Scope B F (F A) \cowith
--   | unscope => M.fmap (\lam (y : A) => \case f y \with {
--     | nothing => Free (M.pure y)
--     | just z => Bound z
--   }) e
--
-- \func instantiate {A B : \Set} {F : \Set -> \Set} {M : Monad F} (k : B -> F A) (s : Scope B F (F A)) : F A
--   => s.unscope >>= (\lam v => \case v \with {
--     | Bound b => k b
--     | Free a => a
--   })
--
-- \func abs-inst {A B : \Set} (f : A -> Maybe B) (e : ExprF A) : instantiate _ (abstract f e)  = e
--   => {?}