\import Data.Functor
\import Data.Maybe
\import Function
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta

\class Applicative \extends Functor
  | pure {A : \Type} : A -> F A
  | ap \alias \infixl 4 ⊛ {A B : \Type} : F (A -> B) -> F A -> F B
  | pure-identity {A : \Type} {v : F A} : pure id ⊛ v = v
  | pure-comp {A B C : \Type} {U : F (B -> C)} {V : F (A -> B)} {W : F A} : pure (o) ⊛ U ⊛ V ⊛ W = U ⊛ (V ⊛ W)
  | pure-homo {A B : \Type} {f : A -> B} {x : A} : pure f ⊛ pure x = pure (f x)
  | pure-interchange {A B : \Type} {u : F (A -> B)} {x : A} : u ⊛ pure x = pure {\this} {(A -> B) -> B} (__ x) ⊛ u

-- \func pure-app {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} {v : F A} : pure f ⊛ v = f <$> v
--  => {?}

\func mult {F : \Type -> \Type} {AppF : Applicative F} {A B : \Type} : F A -> F B -> F (\Sigma A B)
  => \lam fa fb => pure (\lam a b => (a, b)) ⊛ fa ⊛ fb

\func mult' {F : \Type -> \Type} {AppF : Applicative F} {A B : \Type} : F (\Sigma A B) -> (\Sigma (F A) (F B))
  => \lam fab => ((\lam x => x.1) <$> fab, (\lam x => x.2) <$> fab)

\func pure-app {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} {v : F A} : pure f ⊛ v = f <$> v
  => {?}

\func IdApplicative : Applicative id \cowith
  | fmap => IdFunctor.fmap
  | fmap-id => IdFunctor.fmap-id
  | fmap-comp {_ B C : \Type} {_} {g : B -> C} => IdFunctor.fmap-comp {_} {_} {_} {_} {g}
  | pure => id
  | ap => __ __
  | pure-identity => idp
  | pure-comp => idp
  | pure-homo => idp
  | pure-interchange => idp

\func CompApplicative (F G : \Type -> \Type) {AppF : Applicative F} {AppG : Applicative G} : Applicative (F o G) \cowith
  | fmap => fmap {CompFunctor F G {AppF} {AppG}}
  | fmap-id => fmap-id {CompFunctor F G}
  | fmap-comp => fmap-comp {CompFunctor F G}
  | pure => pure o pure
  | ap => (⊛) <$> __ ⊛ __
  | pure-identity => {?}
  | pure-comp => {?}
  | pure-homo => {?}
  | pure-interchange => {?}

\class AppTrans (F G : \Set -> \Set) {AppF : Applicative F} {AppG : Applicative G}
  | trans {A : \Set} : F A -> G A
  | trans-id-pure {A : \Set} {x : A} : trans (pure x) = pure x
  | trans-comm-ap {A B : \Set} {f : F (A -> B)} {x : F A}
    : trans (f ⊛ x) = trans f ⊛ trans x


\data Expr (ctx : \Set) : \Set
  | var (global_index : ctx)
  | num (n : Int)
  | app (e1 : Expr ctx) (e2 : Expr ctx)
  | lam (e : Expr (Maybe ctx))

\data Void

-- empty context
\func zz : Expr Void => num 2
\func qwe : Expr Void => lam nothing -- identity function, Nothing points to the first lambda

\data MyGlobalDefinitions
  | FunctionFold
  | FuncionFmap
  | DataNat
  | DataInt
  | RecordApplicative
  | RecordTraversable

-- non empty context
\func dscv : Expr MyGlobalDefinitions => var FunctionFold

-- traverse id
\func tyuio : Expr MyGlobalDefinitions => app (var FunctionTraverse) (lam Nothing)