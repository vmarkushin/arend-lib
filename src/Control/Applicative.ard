\import Data.Functor
\import Function
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta

\class Applicative \extends Functor
  | pure {A : \Type} : A -> F A
  | ap \alias \infixl 4 ⊛ {A B : \Type} : F (A -> B) -> F A -> F B
  | pure-identity {A : \Type} {v : F A} : pure id ⊛ v = v
  | pure-comp {A B C : \Type} {U : F (B -> C)} {V : F (A -> B)} {W : F A} : pure (o) ⊛ U ⊛ V ⊛ W = U ⊛ (V ⊛ W)
  | pure-homo {A B : \Type} {f : A -> B} {x : A} : pure f ⊛ pure x = pure (f x)
  | pure-interchange {A B : \Type} {u : F (A -> B)} {x : A} : u ⊛ pure x = pure {\this} {(A -> B) -> B} (__ x) ⊛ u

\func mult {F : \Type -> \Type} {AppF : Applicative F} {A B : \Type} : F A -> F B -> F (\Sigma A B)
  => pure (__, __) ⊛ __ ⊛ __

\func IdApplicative : Applicative id \cowith
  | fmap => IdFunctor.fmap
  | fmap-id => IdFunctor.fmap-id
  | fmap-comp {_ B C : \Type} {_} {g : B -> C} => IdFunctor.fmap-comp {_} {_} {_} {_} {g}
  | pure => id
  | ap => __ __
  | pure-identity => idp
  | pure-comp => idp
  | pure-homo => idp
  | pure-interchange => idp

\func CompApplicative (F G : \Type -> \Type) {AppF : Applicative F} {AppG : Applicative G} : Applicative (F o G) \cowith
  | fmap => fmap {CompFunctor F G {AppF} {AppG}}
  | fmap-id => fmap-id {CompFunctor F G}
  | fmap-comp => fmap-comp {CompFunctor F G}
  | pure => pure o pure
  | ap => (⊛) <$> __ ⊛ __
  | pure-identity => {?}
  | pure-comp => {?}
  | pure-homo => {?}
  | pure-interchange => {?}

\class AppTrans (F G : \Type -> \Type) {AppF : Applicative F} {AppG : Applicative G}
  | trans {A : \Type} : F A -> G A
  | trans-id-pure {A : \Type} {x : A} : trans (pure x) = pure x
  | trans-comm-ap {A B : \Type} {f : F (A -> B)} {x : F A} : trans (f ⊛ x) = trans f ⊛ trans x

-- gut feeling that it's kinda OK
\func app-trans-natural {F G : \Type -> \Type} {AppF : Applicative F} {AppG : Applicative G} {AT : AppTrans F G} {A B : \Type} {f : A -> B}
  : AT.trans o AppF.fmap f = AppG.fmap f o AT.trans
  => ext (\lam x => {?})

\func pure-is-app-trans {F : \Type -> \Type} {AppF : Applicative F} : AppTrans id F {IdApplicative} {AppF} \cowith
  | trans => AppF.pure
  | trans-id-pure => idp
  | trans-comm-ap => rewrite AppF.pure-homo idp

\func fmap-pure-pointfree {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} : AppF.pure o f = fmap f o pure
  => app-trans-natural {id} {F} {IdApplicative} {AppF} {pure-is-app-trans}

\func fmap-pure {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} {x : A} : AppF.pure (f x) = f <$> pure x
  => pmap (__ x) fmap-pure-pointfree