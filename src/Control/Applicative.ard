\import Data.Functor
\import Function
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta

\class Applicative \extends Functor {
  | pure {A : \Type} : A -> F A
  | ap \alias \infixl 4 ⊛ {A B : \Type} : F (A -> B) -> F A -> F B
  | pure-identity {A : \Type} {v : F A} : pure id ⊛ v = v
  | pure-comp {A B C : \Type} {U : F (B -> C)} {V : F (A -> B)} {W : F A} : pure (o) ⊛ U ⊛ V ⊛ W = U ⊛ (V ⊛ W)
  | pure-homo {A B : \Type} {f : A -> B} {x : A} : pure f ⊛ pure x = pure (f x)
  | pure-interchange {A B : \Type} {u : F (A -> B)} {x : A} : u ⊛ pure x = pure {\this} {(A -> B) -> B} (__ x) ⊛ u

  \func mult {AppF : Applicative F} {A B : \Type} : F A -> F B -> F (\Sigma A B)
    => pure (__, __) ⊛ __ ⊛ __
}

-- \func pure-identity-pointfree {A : \Type} {F : \Type -> \Type} {AppF : Applicative F} : AppF.ap (pure (id {A -> A})) = id {F (A -> A)}
--   => ext (\lam _ => pure-identity)

-- \func pure-identity-pointfree' {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} : AppF.ap o AppF.pure {A -> B} = AppF.fmap
--   => ext (\lam x f => {?})

-- \func pure-identity-pointfree'' {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} : AppF.ap (pure f) = fmap f
--  => pmap (__ f) pure-identity-pointfree'

-- \func pure-homo-pointfree1 {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} : ap (pure f) o pure = AppF.pure o f
--   => ext (\lam _ => pure-homo)

-- \func pure-homo-pointfree2 {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {x : A} : (\lam (f : A -> B) => pure f ⊛ pure x) = (\lam f => AppF.pure (f x))
--   => ext (\lam _ => pure-homo)

-- \func pure-homo-pointfree-both {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} : (\lam (f : A -> B) (x : A) => pure f ⊛ pure x) = (o AppF.pure)
--   => ext (\lam _ _ => pure-homo)

\func IdApplicative : Applicative id \cowith
  | fmap => IdFunctor.fmap
  | fmap-id => IdFunctor.fmap-id
  | fmap-comp {_ B C : \Type} {_} {g : B -> C} => IdFunctor.fmap-comp {_} {_} {_} {_} {g}
  | pure => id
  | ap => __ __
  | pure-identity => idp
  | pure-comp => idp
  | pure-homo => idp
  | pure-interchange => idp

\class AppTrans (F G : \Type -> \Type) {AppF : Applicative F} {AppG : Applicative G}
  | trans {A : \Type} : F A -> G A
  | trans-id-pure {A : \Type} {x : A} : trans (pure x) = pure x
  | trans-comm-ap {A B : \Type} {f : F (A -> B)} {x : F A} : trans (f ⊛ x) = trans f ⊛ trans x

-- gut feeling that it's kinda OK
\func app-trans-natural {F G : \Type -> \Type} {AppF : Applicative F} {AppG : Applicative G} {AT : AppTrans F G} {A B : \Type} {f : A -> B}
  : AT.trans o AppF.fmap f = AppG.fmap f o AT.trans
  => ext (\lam x => {?})

\func pure-is-app-trans {F : \Type -> \Type} {AppF : Applicative F} : AppTrans id F {IdApplicative} {AppF} \cowith
  | trans => AppF.pure
  | trans-id-pure => idp
  | trans-comm-ap => rewrite AppF.pure-homo idp

\func fmap-pure-pointfree {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} : AppF.pure o f = fmap f o pure
  => app-trans-natural {id} {F} {IdApplicative} {AppF} {pure-is-app-trans}

\func fmap-pure {A B : \Type} {F : \Type -> \Type} {AppF : Applicative F} {f : A -> B} {x : A} : AppF.pure (f x) = f <$> pure x
  => pmap (__ x) fmap-pure-pointfree

\func CompApplicative (F G : \Type -> \Type) {AppF : Applicative F} {AppG : Applicative G} : Applicative (F o G) \cowith
  | fmap => fmap {CompFunctor F G {AppF} {AppG}}
  | fmap-id => fmap-id {CompFunctor F G}
  | fmap-comp => fmap-comp {CompFunctor F G}
  | pure => pure o pure
  | ap => (⊛) <$> __ ⊛ __
  | pure-identity {A} {v} => run {
      rewrite (fmap-pure {_} {_} {F} {AppF} {AppG.pure}),
      rewriteI (AppF.fmap-comp),
      rewriteI (fmap-pure {_} {_} {F} {AppF} ),
      rewriteI {4} AppF.pure-identity,
      pmap (__ ⊛ v),
      pmap pure,
      ext (\lam _ => pure-identity)
  }
  | pure-comp => {?}
  | pure-homo => {?}
  | pure-interchange => {?}