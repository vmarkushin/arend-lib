\import Data.Functor
\import Function
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta

\class Applicative \extends Functor
  | pure {A : \Type} : A -> F A
  | ap \alias \infixl 4 ⊗ {A B : \Type} : F (A -> B) -> F A -> F B
  | pure-identity {A : \Type} {v : F A} : pure id ⊗ v = v
  | pure-comp {A B C : \Type} {U : F (B -> C)} {V : F (A -> B)} {W : F A} : pure (o) ⊗ U ⊗ V ⊗ W = U ⊗ (V ⊗ W)
  | pure-homo {A B : \Type} {f : A -> B} {x : A} : pure f ⊗ pure x = pure (f x)
  | pure-interchange {A B : \Type} {u : F (A -> B)} {x : A} : u ⊗ pure x = pure {\this} {(A -> B) -> B} (__ x) ⊗ u

\func IdApplicative : Applicative id \cowith
  | fmap => IdFunctor.fmap
  | fmap-id => IdFunctor.fmap-id
  | fmap-comp => idp
  | pure => id
  | ap => __ __
  | pure-identity => idp
  | pure-comp => idp
  | pure-homo => idp
  | pure-interchange => idp

{-

 -}

-- original: AppF.fmap (AppG.⊗) ((o) AppF.pure AppG.pure id) AppF.⊗ v = v
--   Expected type: AppF.fmap (AppG.⊗) ((o) AppF.pure AppG.pure id) AppF.⊗ v = AppF.pure id AppF.⊗ v

\func CompApplicative (F G : \Type -> \Type) {AppF : Applicative F} {AppG : Applicative G} : Applicative (F o G) \cowith
  | fmap => fmap {CompFunctor F G}
  | fmap-id => fmap-id {CompFunctor F G}
  | fmap-comp => fmap-comp {CompFunctor F G}
  | pure => pure o pure
  | ap => fmap (⊗) __ ⊗ __
  | pure-identity {A} {v} => rewriteI {5} AppF.pure-identity $ pmap (__ ⊗ v) $ {?}
  | pure-comp => {?}
  | pure-homo => {?}
  | pure-interchange => {?}
